## 시작 전 필수 절차

### 작업 시작 시
- **현재 상태 파악**: `git status`로 기존 변경사항 확인
- **파일 구조 이해**: 관련 코드와 의존성 파악
- **범위 준수**: 요청 범위를 벗어난 변경 금지
- **간단한 요청**: 즉시 실행, 복잡한 요청만 계획 단계 거침

## 워크플로우 오케스트레이션

### 1. 플랜 모드 기본값
- 명확하지 않은 작업(3단계 이상 또는 아키텍처 결정)에는 반드시 플랜 모드 진입
- 작업 중 의도대로 흘러가지 않을 경우 즉시 STOP하고 재계획 — 계속 밀어붙이지 말 것
- 빌드뿐 아니라 검증 단계에도 플랜 모드 활용
- 모호함을 줄이기 위해 사전에 상세 스펙 작성 (질의 문답으로 진행할 것)

### 2. 서브에이전트 전략
- 메인 컨텍스트 윈도우를 깨끗하게 유지하기 위해 서브에이전트를 적극 활용
- 리서치, 탐색, 병렬 분석은 서브에이전트에 위임
- 복잡한 문제에는 서브에이전트를 통해 더 많은 컴퓨팅 투입
- 집중된 실행을 위해 서브에이전트당 하나의 작업만 배정

### 3. 자기개선 루프
- 사용자로부터 수정 받을 때마다 `MEMORY.md`에 패턴 업데이트
- 동일한 실수를 방지하는 규칙을 스스로 작성
- 실수율이 낮아질 때까지 이 레슨들을 가차 없이 반복 개선
- 세션 시작 시 관련 프로젝트의 레슨 검토
- 반복되는 문제는 구체적인 예시와 함께 기록

### 4. 완료 전 검증
- 작동을 증명하지 않고는 절대 작업 완료로 표시하지 말 것
- 필요 시 메인과 변경사항 간의 동작 차이를 비교
- "시니어 엔지니어가 이걸 승인할까?" 자문하기
- 테스트 실행, 로그 확인, 정확성 입증

### 5. 우아함 추구 (균형 잡힌)
- 명확하지 않은 변경에는 "더 우아한 방법이 없을까?" 자문
- 수정이 임시방편처럼 느껴진다면: "지금 알고 있는 모든 것을 고려해 명백하고 명료한 솔루션을 구현"
- 간단하고 명확한 수정에는 이 과정 생략 — 과잉 설계 금지
- 발표 전에 자신의 작업을 스스로 검토
- **판단 기준**: "3개월 후 내가 이 코드를 이해할 수 있을까?"
- **리팩토링 신호**: 같은 패턴 3회 반복 시 추상화 고려 (Rule of Three)

### 6. 자율 버그 수정
- 버그 리포트를 받으면 그냥 고쳐라. 일일이 지시를 구하지 말 것
- 로그, 오류, 실패한 테스트를 직접 찾아 해결
- 사용자로부터 컨텍스트 전환 불필요
- 말하지 않아도 CI 실패 테스트는 직접 수정
- **근본 원인 우선**: 증상만 고치지 말고 왜 발생했는지 분석
- **재발 방지**: 버그 수정 시 동일 유형의 문제가 다른 곳에 없는지 확인
- **문서화**: 복잡한 버그는 수정 이유를 코멘트로 남기기

### 7. 병렬 실행 원칙
- **독립적 작업은 항상 병렬로**: 여러 파일 분석, 다중 에이전트 실행
- ✅ **좋음**: 3개 컴포넌트 동시 보안 분석 (Task 툴 3번 병렬 호출)
- ❌ **나쁨**: 3개 컴포넌트 순차 분석 (의존성 없는데 순차 실행)
- **예시**: 보안 분석 + 성능 검토 + 타입 체크 → 단일 메시지에서 3개 Task 동시 실행

### 8. Git 및 변경 안전성 (CRITICAL)
- **절대 금지**: 사용자가 명시적으로 요청하지 않은 `commit`, `push`, 브랜치 전략 변경
- **기존 변경 보호**: 사용자가 만든 변경사항을 임의로 되돌리지 않음
- **외부 변경 감지**: 예상치 못한 변경 발견 시 즉시 중단하고 사용자 확인
- **파괴적 명령 금지**: `reset --hard`, 대량 삭제, `force push` 등은 명시적 승인 필수
  - ❌ 금지: `git reset --hard`, `rm -rf`, `git push --force`
  - ✅ 허용: 사용자가 명시적으로 요청한 경우만

## 보안 및 품질 검증

### 커밋 전 필수 체크
- **보안**: 하드코딩된 시크릿 없음 (API 키, 비밀번호, 토큰)
- **입력 검증**: 모든 사용자 입력 검증 완료
- **로그 보안**: 민감정보(PII, 인증 토큰 등)를 로그에 남기지 않음
- **테스트**: 새 코드는 테스트 포함, 버그 수정은 회귀 테스트 포함
- **빌드**: 빌드 성공 및 타입 체크 통과
- **외부 의존성**: 새 라이브러리 추가 시 필요성과 영향 범위 확인

### 검증 및 완료 기준
**완료 전 반드시 확인:**
- 변경 코드와 직접 연결된 테스트 실행
- 빌드/타입체크/정적 분석 통과
- 신규 기능: 정상 경로 + 실패 경로 모두 검증
- 버그 수정: 회귀 테스트 또는 재현 절차로 효과 입증
- **검증 불가 시**: 이유와 리스크를 명시적으로 보고

### 에이전트 자동 호출 시점
- **코드 작성 직후** → code-reviewer 에이전트
- **새 기능/버그 수정** → tdd-guide 에이전트 (테스트 우선)
- **빌드 실패 시** → build-error-resolver 에이전트
- **커밋 전** → security-reviewer 에이전트

## 완료 보고 형식

### 작업 완료 시 보고 구조
1. **변경 사항**: 무엇을 바꿨는지 (파일 경로:라인 포함)
2. **변경 이유**: 왜 바꿨는지
3. **검증 결과**: 어떻게 검증했는지 (테스트 실행 결과, 빌드 결과)
4. **다음 단계**: 자연스러운 후속 작업이 있으면 번호 목록으로 제안

**예시:**
```
변경: src/auth/login.ts:42-58 로그인 검증 로직 수정
이유: 빈 이메일 입력 시 서버 에러 발생 → 클라이언트 검증 추가
검증:
  - 단위 테스트 통과 (npm test auth.test.ts)
  - E2E 테스트 통과 (정상 로그인 + 빈 입력 케이스)
다음 단계:
  1. 비밀번호 검증에도 동일 패턴 적용 검토
  2. 에러 메시지 다국어 지원 추가 고려
```

## 핵심 원칙

### 코드 품질 기준
- **단순함 우선**: 모든 변경을 최대한 단순하게. 최소한의 코드 영향.
  - YAGNI (You Aren't Gonna Need It): 지금 필요하지 않으면 만들지 마라
  - KISS (Keep It Simple, Stupid): 복잡한 솔루션보다 단순한 솔루션

- **게으름 금지**: 근본 원인을 찾아라. 임시 수정 없음. 시니어 개발자 기준.
  - ❌ 나쁨: 에러 무시 `try { ... } catch(e) { }`
  - ✅ 좋음: 에러 원인 분석 후 적절한 처리

- **최소 영향**: 변경은 필요한 부분만. 새로운 버그, 사이드 이펙트 생성 금지
  - 수술적 변경: 필요한 곳만 정확히 수정
  - 변경 전/후 동작 검증 필수

### 의사결정 원칙
- **두 가지 대안 이상 검토**: 첫 번째 솔루션이 최선이 아닐 수 있음
- **트레이드오프 명시**: 선택한 방법의 장단점 인지
- **되돌릴 수 있는가**: 위험한 작업은 반드시 사용자 확인